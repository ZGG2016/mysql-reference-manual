# 13.02.15 WITH (Common Table Expressions)

[TOC]

*A common table expression (CTE) is a named temporary result set that exists within the scope of a single statement and that can be referred to later within that statement, possibly multiple times. The following discussion describes how to write statements that use CTEs.*

common table expression (CTE) 是一个存在于一条语句范围内的命名的临时结果集，之后可以在那条语句中引用多次。

下面讨论如何写适用 CTEs 语句：

- [Common Table Expressions](https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions)

- [Recursive Common Table Expressions](https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-recursive)

- [Limiting Common Table Expression Recursion](https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-recursion-limits)

- [Recursive Common Table Expression Examples](https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-recursive-examples)

- [Common Table Expressions Compared to Similar Constructs](https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-similar-constructs)

For information about CTE optimization, see [Section 8.2.2.4, “Optimizing Derived Tables, View References, and Common Table Expressions with Merging or Materialization”](https://dev.mysql.com/doc/refman/8.0/en/derived-table-optimization.html).

## 1、Additional Resources

These articles contain additional information about using CTEs in MySQL, including many examples:

[MySQL 8.0 Labs: [Recursive] Common Table Expressions in MySQL (CTEs)](http://mysqlserverteam.com/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes/)

[MySQL 8.0 Labs: [Recursive] Common Table Expressions in MySQL (CTEs), Part Two – how to generate series](http://mysqlserverteam.com/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes-part-two-how-to-generate-series/)

[MySQL 8.0 Labs: [Recursive] Common Table Expressions in MySQL (CTEs), Part Three – hierarchies](http://mysqlserverteam.com/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes-part-three-hierarchies/)

[MySQL 8.0.1: [Recursive] Common Table Expressions in MySQL (CTEs), Part Four – depth-first or breadth-first traversal, transitive closure, cycle avoidance](http://mysqlserverteam.com/mysql-8-0-1-recursive-common-table-expressions-in-mysql-ctes-part-four-depth-first-or-breadth-first-traversal-transitive-closure-cycle-avoidance/)

## 2、Common Table Expressions

*To specify common table expressions, use a WITH clause that has one or more comma-separated subclauses. Each subclause provides a subquery that produces a result set, and associates a name with the subquery. The following example defines CTEs named cte1 and cte2 in the WITH clause, and refers to them in the top-level SELECT that follows the WITH clause:*

为了指定一个 CTE ，使用一个 有一个或多个逗号分隔的子句的 `WITH` 子句。

每个子句提供一个 能产生一个结果集的子查询语句，及其相关联的名字。

下例，在 `WITH` 子句中定义了名为 `cte1` 和 `cte2` 的 CTEs，并在紧随`WITH` 子句后的顶层的 `SELECT` 中引用它们。

```sql
WITH
  cte1 AS (SELECT a, b FROM table1),
  cte2 AS (SELECT c, d FROM table2)
SELECT b, d FROM cte1 JOIN cte2
WHERE cte1.a = cte2.c;
```

在包含 `WITH` 子句的语句中，可以引用每个 CTE 的名字，来访问对应的 CTE 的结果集。 

一个 CTE 名字可以被其他 CTEs 引用，启用根据其他 CTEs 定义 CTEs.

一个 CTE 可以引用它本身，来定义一个递归的 CTE。递归 CTEs 的常见应用包括序列生成器和层次或树形结构的数据遍历。

*In the statement containing the WITH clause, each CTE name can be referenced to access the corresponding CTE result set.*

*A CTE name can be referenced in other CTEs, enabling CTEs to be defined based on other CTEs.*

*A CTE can refer to itself to define a recursive CTE. Common applications of recursive CTEs include series generation and traversal of hierarchical or tree-structured data.*

*Common table expressions are an optional part of the syntax for DML statements. They are defined using a WITH clause:*

对 DML 语句来说，CTE 是语法的可选的一部分。如下定义：

```sql
with_clause:
    WITH [RECURSIVE]
        cte_name [(col_name [, col_name] ...)] AS (subquery)
        [, cte_name [(col_name [, col_name] ...)] AS (subquery)] ..

```

`cte_name` 是一个独立的 CTE ，可以在包含 `WITH` 子句的语句中用作表引用。

`AS (subquery)` 的 `subquery` 称为"CTE 的子查询"，会产生 CTE 结果集。`AS` 后的括号是必需的。

如果 CTE 的子查询中引用了它自己的名称，那么它就是递归的。如果 `WITH` 子句中的任意的 CTE 是递归的，则必须包含 `RECURSIVE` 关键字。有关更多信息，请参见递归公共表表达式。

*cte_name names a single common table expression and can be used as a table reference in the statement containing the WITH clause.*

*The subquery part of AS (subquery) is called the “subquery of the CTE” and is what produces the CTE result set. The parentheses following AS are required.*

*A common table expression is recursive if its subquery refers to its own name. The RECURSIVE keyword must be included if any CTE in the WITH clause is recursive. For more information, see [Recursive Common Table Expressions](https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-recursive).*

*Determination of column names for a given CTE occurs as follows:*

给定 CTE 的列名的确定如下:

- If a parenthesized list of names follows the CTE name, those names are the column names:

如果 CTE 名称后面有一个带括号的名称列表，那么这些名称就是列名：

```sql
WITH cte (col1, col2) AS
(
  SELECT 1, 2
  UNION ALL
  SELECT 3, 4
)
SELECT col1, col2 FROM cte;
```

*The number of names in the list must be the same as the number of columns in the result set.*

列表中的名字的数量必须和结果集中的列的数量相同。【子查询结果的列的数量和cte后面括号里的数量一致】

- Otherwise, the column names come from the select list of the first SELECT within the AS (subquery) part:

否则，列名来自 `AS (subquery)` 中的第一个 SELECT 中的列表：

```sql
WITH cte AS
(
  SELECT 1 AS col1, 2 AS col2
  UNION ALL
  SELECT 3, 4
)
SELECT col1, col2 FROM cte;
```

*A WITH clause is permitted in these contexts:*

`WITH` 子句在这些情景下是被允许的：

- At the beginning of SELECT, UPDATE, and DELETE statements.

```sql
WITH ... SELECT ...
WITH ... UPDATE ...  (???)
WITH ... DELETE ...  (???)
```

- At the beginning of subqueries (including derived table subqueries):

```sql
SELECT ... WHERE id IN (WITH ... SELECT ...) ...
SELECT * FROM (WITH ... SELECT ...) AS dt ...
```
- Immediately preceding SELECT for statements that include a SELECT statement:（??）

```sql
INSERT ... WITH ... SELECT ...
REPLACE ... WITH ... SELECT ...
CREATE TABLE ... WITH ... SELECT ...
CREATE VIEW ... WITH ... SELECT ...
DECLARE CURSOR ... WITH ... SELECT ...
EXPLAIN ... WITH ... SELECT ...
```

*Only one WITH clause is permitted at the same level. WITH followed by WITH at the same level is not permitted, so this is illegal:*

在一个层级下，仅允许一个 `WITH` 子句。下列是不合法的：

```sql
WITH cte1 AS (...) WITH cte2 AS (...) SELECT ...
```
*To make the statement legal, use a single WITH clause that separates the subclauses by a comma:*

为了确保语句合法，使用逗号划分子句的单个 `WITH` 子句，

```sql
WITH cte1 AS (...), cte2 AS (...) SELECT ...
```

*However, a statement can contain multiple WITH clauses if they occur at different levels:*

如果它们出现在不同的层级，一个语句是可以包含多个 `WITH` 子句

```sql
WITH cte1 AS (SELECT 1)
SELECT * FROM (WITH cte2 AS (SELECT 2) SELECT * FROM cte2 JOIN cte1) AS dt;
```

*A WITH clause can define one or more common table expressions, but each CTE name must be unique to the clause. This is illegal:*

一个 `WITH` 子句可以定义一个或多个 CTE，但名字必须不同。下列是不合法的：

```sql
WITH cte1 AS (...), cte1 AS (...) SELECT ...
```

*To make the statement legal, define the CTEs with unique names:*

```sql
WITH cte1 AS (...), cte2 AS (...) SELECT ...
```

*A CTE can refer to itself or to other CTEs:*

一个 CTE 可以引用本身或其他的 CTEs：

- A self-referencing CTE is recursive. 引用自身是递归

- A CTE can refer to CTEs defined earlier in the same WITH clause, but not those defined later. 一个 CTE 可以引用 `WITH` 子句中在它前面定义的 CTEs，而不能是后面定义的。

- This constraint rules out mutually-recursive CTEs, where cte1 references cte2 and cte2 references cte1. One of those references must be to a CTE defined later, which is not permitted.这个约束排除了相互递归的 CTE，即 CTE1 引用 CTE2, CTE2 引用 CTE1 。其中一个引用是后来定义的 CTE，这是不允许的。

- A CTE in a given query block can refer to CTEs defined in query blocks at a more outer level, but not CTEs defined in query blocks at a more inner level.给定查询块中的 CTE 可以引用在更外层的查询块中定义的 CTE，但不能引用在更内部的查询块中定义的 CTE。

*For resolving references to objects with the same names, derived tables hide CTEs; and CTEs hide base tables, TEMPORARY tables, and views. Name resolution occurs by searching for objects in the same query block, then proceeding to outer blocks in turn while no object with the name is found.*

为了解析对同名对象的引用，派生表隐藏了 CTEs；CTEs 隐藏基表、临时表和视图。名称解析出现在同一个查询块中搜索对象，然后在没有找到具有该名称的对象时依次转向外部块。

*Like derived tables, a CTE cannot contain outer references prior to MySQL 8.0.14. This is a MySQL restriction that is lifted in MySQL 8.0.14, not a restriction of the SQL standard. For additional syntax considerations specific to recursive CTEs, see [Recursive Common Table Expressions](https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-recursive).*

像派生表一样，CTE 不能包含 MySQL 8.0.14 之前的外部引用。这是在 MySQL 8.0.14 中取消的 MySQL 限制，而不是 SQL 标准的限制。

**实操：**

```sql
mysql> select * from dept_emp;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10001 | d001    | 1986-06-26 | 9999-01-01 |
|  10002 | d001    | 1996-08-03 | 9999-01-01 |
|  10003 | d004    | 1995-12-03 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  10005 | d003    | 1989-09-12 | 9999-01-01 |
|  10006 | d002    | 1990-08-05 | 9999-01-01 |
|  10007 | d005    | 1989-02-10 | 9999-01-01 |
|  10008 | d005    | 1998-03-11 | 2000-07-31 |
|  10009 | d006    | 1985-02-18 | 9999-01-01 |
|  10010 | d005    | 1996-11-24 | 2000-06-26 |
|  10010 | d006    | 2000-06-26 | 9999-01-01 |
+--------+---------+------------+------------+
11 rows in set (0.00 sec)

-- 定义一个 CTE
mysql> with
    -> cte1 as (select * from dept_emp where dept_no='d005')
    -> select * from cte1 where from_date>'1989-02-10';
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10008 | d005    | 1998-03-11 | 2000-07-31 |
|  10010 | d005    | 1996-11-24 | 2000-06-26 |
+--------+---------+------------+------------+
2 rows in set (0.00 sec)

-- 定义两个 CTE
mysql> with
    -> cte1 as (select * from dept_emp where dept_no='d005'),
    -> cte2 as (select * from dept_emp where dept_no='d006')
    -> select * from cte1
    -> union all 
    -> select * from cte2;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10007 | d005    | 1989-02-10 | 9999-01-01 |
|  10008 | d005    | 1998-03-11 | 2000-07-31 |
|  10010 | d005    | 1996-11-24 | 2000-06-26 |
|  10009 | d006    | 1985-02-18 | 9999-01-01 |
|  10010 | d006    | 2000-06-26 | 9999-01-01 |
+--------+---------+------------+------------+
5 rows in set (0.00 sec)

-- CTE 名称后面有一个带括号的名称列表，那么这些名称就是列名(cte的列名)
-- 列表中的名字的数量必须和结果集中的列的数量相同。
mysql> with
    -> cte1 (emp_no,dept_no) as (select * from dept_emp where dept_no='d005')
    -> select * from cte1;
ERROR 1353 (HY000): In definition of view, derived table or common table expression, SELECT list and column names list have different column counts
mysql> with
    -> cte1 (emp_no,dept_no) as (select emp_no,dept_no from dept_emp where dept_no='d005') 
    -> select * from cte1;
+--------+---------+
| emp_no | dept_no |
+--------+---------+
|  10007 | d005    |
|  10008 | d005    |
|  10010 | d005    |
+--------+---------+
3 rows in set (0.01 sec)

-- 否则，列名来自 AS (subquery) 中的第一个 SELECT 中的列表：
mysql> with
    -> cte1 as (select emp_no,dept_no from dept_emp where dept_no='d005') 
    -> select * from cte1;
+--------+---------+
| emp_no | dept_no |
+--------+---------+
|  10007 | d005    |
|  10008 | d005    |
|  10010 | d005    |
+--------+---------+
3 rows in set (0.00 sec)

-- At the beginning of subqueries (including derived table subqueries):
mysql> select emp_no,dept_no
    -> from dept_emp
    -> where from_date in (
    -> with cte1 as (select * from dept_emp where dept_no='d005')
    -> select from_date from cte1); 
+--------+---------+
| emp_no | dept_no |
+--------+---------+
|  10007 | d005    |
|  10008 | d005    |
|  10010 | d005    |
+--------+---------+
3 rows in set (0.00 sec)

-- Immediately preceding SELECT for statements that include a SELECT statement
--CREATE VIEW ... WITH ... SELECT ...
mysql> create view dev as
    -> with
    -> cte1 as (select * from dept_emp where dept_no='d005')
    -> select * from cte1 where from_date>'1989-02-10'; 
Query OK, 0 rows affected (0.02 sec)

mysql> select * from dev;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10008 | d005    | 1998-03-11 | 2000-07-31 |
|  10010 | d005    | 1996-11-24 | 2000-06-26 |
+--------+---------+------------+------------+
2 rows in set (0.00 sec)

--INSERT ... WITH ... SELECT ...
mysql> insert into dept_emp
    -> with
    -> cte1 as (select * from dept_emp_bk where dept_no='d005')        
    -> select * from cte1 where emp_no=10011;
Query OK, 1 row affected (0.00 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> select * from dept_emp;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10001 | d001    | 1986-06-26 | 9999-01-01 |
|  10002 | d001    | 1996-08-03 | 9999-01-01 |
|  10003 | d004    | 1995-12-03 | 9999-01-01 |
|  10004 | d004    | 1986-12-01 | 9999-01-01 |
|  10005 | d003    | 1989-09-12 | 9999-01-01 |
|  10006 | d002    | 1990-08-05 | 9999-01-01 |
|  10007 | d005    | 1989-02-10 | 9999-01-01 |
|  10008 | d005    | 1998-03-11 | 2000-07-31 |
|  10009 | d006    | 1985-02-18 | 9999-01-01 |
|  10010 | d005    | 1996-11-24 | 2000-06-26 |
|  10010 | d006    | 2000-06-26 | 9999-01-01 |
|  10011 | d005    | 1997-11-12 | 9999-01-01 |
+--------+---------+------------+------------+
12 rows in set (0.00 sec)

mysql> with cte1 as (select * from dept_emp) with cte2 as (select * from dept_emp) 
    -> select * from cte1 union all select * from cte2;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'with cte2 as (select * from dept_emp)
select * from cte1 union all select * from' at line 1
ERROR: 
No query specified
```

## 3、Recursive Common Table Expressions

*A recursive common table expression is one having a subquery that refers to its own name. For example:*

一个递归的 CTE 有一个引用自己名字的子查询。

```sql
WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte WHERE n < 5
)
SELECT * FROM cte;
```

*When executed, the statement produces this result, a single column containing a simple linear sequence:*

```sql
+------+
| n    |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+
```

*A recursive CTE has this structure:*

*The WITH clause must begin with WITH RECURSIVE if any CTE in the WITH clause refers to itself. (If no CTE refers to itself, RECURSIVE is permitted but not required.)*

*If you forget RECURSIVE for a recursive CTE, this error is a likely result:*

一个递归的 CTE 有如下结构:

- `WITH` 子句必须以 `WITH RECURSIVE` 开始，如果在 `WITH` 子句中的任意 CTE 引用了自身。如果没写 `RECURSIVE`，会出现如下错误：

		ERROR 1146 (42S02): Table 'cte_name' doesn't exist

*The recursive CTE subquery has two parts, separated by UNION [ALL] or UNION DISTINCT:*

递归 CTE 的子查询有两部分，由 UNION [ALL] 或 UNION DISTINCT 分隔：

```sql
SELECT ...      -- return initial row set
UNION ALL
SELECT ...      -- return additional row sets
```

第一个 SELECT 产生原始行，或是 CTE 的行，不会引用 CTE 名称。

第一个 SELECT 产生额外的行，通过在 FROM 子句中引用 CTE 名称。当这部分不再产生新行时，递归结束。

因此，递归 CTE 由一个非递归 SELECT 部分和一个递归 SELECT 部分组成。

*The first SELECT produces the initial row or rows for the CTE and does not refer to the CTE name. The second SELECT produces additional rows and recurses by referring to the CTE name in its FROM clause. Recursion ends when this part produces no new rows. Thus, a recursive CTE consists of a nonrecursive SELECT part followed by a recursive SELECT part.*

*Each SELECT part can itself be a union of multiple SELECT statements.*

每个 SELECT 部分可以是多个 SELECT 语句的并集。

- CTE 结果的列类型仅根据非递归 SELECT 部分的列类型推断出来，并且列都是可空的。对于类型确定，将忽略递归 SELECT 部分。

- 如果非递归部分和递归部分由 UNION DISTINCT 分隔，则可以消除重复行。这对于执行传递闭包的查询非常有用，可以避免无限循环。

- 递归部分的每次迭代只对前一次迭代产生的行进行操作。如果递归部分有多个查询块，则每个查询块的迭代都以未指定的顺序调度，并且每个查询块都对其前一次迭代或前一次迭代结束后的其他查询块生成的行进行操作。

*The types of the CTE result columns are inferred from the column types of the nonrecursive SELECT part only, and the columns are all nullable. For type determination, the recursive SELECT part is ignored.*

*If the nonrecursive and recursive parts are separated by UNION DISTINCT, duplicate rows are eliminated. This is useful for queries that perform transitive closures, to avoid infinite loops.*

*Each iteration of the recursive part operates only on the rows produced by the previous iteration. If the recursive part has multiple query blocks, iterations of each query block are scheduled in unspecified order, and each query block operates on rows that have been produced either by its previous iteration or by other query blocks since that previous iteration's end.*

*The recursive CTE subquery shown earlier has this nonrecursive part that retrieves a single row to produce the initial row set:*

前面显示的递归 CTE 的子查询有这个非递归部分，它检索单行，以生成初始行集:

```sql
SELECT 1
```

*The CTE subquery also has this recursive part:*

CTE 子查询也有这个递归部分：

```sql
SELECT n + 1 FROM cte WHERE n < 5
```

*At each iteration, that SELECT produces a row with a new value one greater than the value of n from the previous row set. The first iteration operates on the initial row set (1) and produces 1+1=2; the second iteration operates on the first iteration's row set (2) and produces 2+1=3; and so forth. This continues until recursion ends, which occurs when n is no longer less than 5.*

*If the recursive part of a CTE produces wider values for a column than the nonrecursive part, it may be necessary to widen the column in the nonrecursive part to avoid data truncation. Consider this statement:*

在每次迭代时，SELECT 会产生一个新值比前一行集合的 n 值大1的行。

	第一次迭代对初始行集(1)进行操作，生成 1+1=2;

	第二次迭代操作第一次迭代产生的行集(2)，得到 2+1=3;等等。

	这个过程一直持续到递归结束，即n不再小于5时结束。

如果 CTE 的递归部分比非递归部分产生更宽的列值，则可能有必要扩大非递归部分的列，以避免数据截断。

考虑下面的语句:

```sql
WITH RECURSIVE cte AS
(
  SELECT 1 AS n, 'abc' AS str
  UNION ALL
  SELECT n + 1, CONCAT(str, str) FROM cte WHERE n < 3
)
SELECT * FROM cte;
```
*In nonstrict SQL mode, the statement produces this output:*

在 nonstrict 模式下，语句会产生如下输出：

```sql
+------+------+
| n    | str  |
+------+------+
|    1 | abc  |
|    2 | abc  |
|    3 | abc  |
+------+------+
```
str 列的值都是 "abc"，因为非递归选择决定了列的宽度。因此，递归 SELECT 产生的更宽的 str 值被截断。

*The str column values are all 'abc' because the nonrecursive SELECT determines the column widths. Consequently, the wider str values produced by the recursive SELECT are truncated.*

*In strict SQL mode, the statement produces an error:*

在 strict 模式下，语句会产生如下输出错误：

	ERROR 1406 (22001): Data too long for column 'str' at row 1

*To address this issue, so that the statement does not produce truncation or errors, use CAST() in the nonrecursive SELECT to make the str column wider:*

为了解决这个问题，使语句不会产生截断或错误，可以在非递归 SELECT 中使用 CAST() 来扩大 str 列:

```sql
WITH RECURSIVE cte AS
(
  SELECT 1 AS n, CAST('abc' AS CHAR(20)) AS str
  UNION ALL
  SELECT n + 1, CONCAT(str, str) FROM cte WHERE n < 3
)
SELECT * FROM cte;
```

*Now the statement produces this result, without truncation:*

	+------+--------------+
	| n    | str          |
	+------+--------------+
	|    1 | abc          |
	|    2 | abcabc       |
	|    3 | abcabcabcabc |
	+------+--------------+

*Columns are accessed by name, not position, which means that columns in the recursive part can access columns in the nonrecursive part that have a different position, as this CTE illustrates:*

列是通过列名称而不是位置访问的，这意味着递归部分的列可以访问非递归部分中不同位置的列，如这个 CTE 所示:

```sql
WITH RECURSIVE cte AS
(
  SELECT 1 AS n, 1 AS p, -1 AS q
  UNION ALL
  SELECT n + 1, q * 2, p * 2 FROM cte WHERE n < 5
)
SELECT * FROM cte;
```

*Because p in one row is derived from q in the previous row, and vice versa, the positive and negative values swap positions in each successive row of the output:*

因为一行中的 p 是从前一行的 q 派生出来的，反之亦然，所以输出的每一行的正负值位置互换:

	+------+------+------+
	| n    | p    | q    |
	+------+------+------+
	|    1 |    1 |   -1 |
	|    2 |   -2 |    2 |
	|    3 |    4 |   -4 |
	|    4 |   -8 |    8 |
	|    5 |   16 |  -16 |
	+------+------+------+

*Some syntax constraints apply within recursive CTE subqueries:*

在递归的 CTE 子查询中有一些语法限制：

*The recursive SELECT part must not contain these constructs:*

(1)递归的 SELECT 部分不能包含如下结构：

- Aggregate functions such as SUM()

- Window functions

- GROUP BY

- ORDER BY

- DISTINCT

MySQL 8.0.19 之前的版本，递归 CTE 的递归 SELECT 部分也不能使用 `LIMIT` 子句。这个限制在 MySQL 8.0.19 解除了，现在支持 `LIMIT` 和 `OFFSET`。对结果集的影响与在最外层 SELECT 中使用 `LIMIT` 时相同，但效率更高，因为在递归 SELECT 中使用它时，一旦产生了请求的行数，就会停止行的生成。

这些约束不适用于递归 CTE 的非递归 SELECT 部分。DISTINCT 只适用于 UNION 成员；允许 `UNION DISTINCT`。

(2)递归 SELECT 部分只能在它的 FROM 子句中引用 CTE 一次，而不能在任何子查询中引用。它可以引用除了 CTE 以外的表，并将它们与 CTE join。如果在这样的 join 中使用，CTE 不能位于 LEFT JOIN 的右侧。

*Prior to MySQL 8.0.19, the recursive SELECT part of a recursive CTE also could not use a LIMIT clause. This restriction is lifted in MySQL 8.0.19, and LIMIT is now supported in such cases, along with an optional OFFSET clause. The effect on the result set is the same as when using LIMIT in the outermost SELECT, but is also more efficient, since using it with the recursive SELECT stops the generation of rows as soon as the requested number of them has been produced.*

*These constraints do not apply to the nonrecursive SELECT part of a recursive CTE. The prohibition on DISTINCT applies only to UNION members; UNION DISTINCT is permitted.*

*The recursive SELECT part must reference the CTE only once and only in its FROM clause, not in any subquery. It can reference tables other than the CTE and join them with the CTE. If used in a join like this, the CTE must not be on the right side of a LEFT JOIN.*

*These constraints come from the SQL standard, other than the MySQL-specific exclusions of ORDER BY, LIMIT (MySQL 8.0.18 and earlier), and DISTINCT.*

*For recursive CTEs, EXPLAIN output rows for recursive SELECT parts display Recursive in the Extra column.*

*Cost estimates displayed by EXPLAIN represent cost per iteration, which might differ considerably from total cost. The optimizer cannot predict the number of iterations because it cannot predict at what point the WHERE clause becomes false.*

*CTE actual cost may also be affected by result set size. A CTE that produces many rows may require an internal temporary table large enough to be converted from in-memory to on-disk format and may suffer a performance penalty. If so, increasing the permitted in-memory temporary table size may improve performance; see [Section 8.4.4, “Internal Temporary Table Use in MySQL”](https://dev.mysql.com/doc/refman/8.0/en/internal-temporary-tables.html).*

除了特定于 MySQL 的 ORDER BY、LIMIT(MySQL 8.0.18和更早版本)和 DISTINCT 之外，这些约束来自 SQL 标准。

对于递归 CTEs，递归 SELECT 部分的 EXPLAIN 输出行在额外列中显示递归。

由 EXPLAIN 显示的成本估计表示每次迭代的成本，它可能与总成本有很大的不同。优化器无法预测迭代的次数，因为它无法预测 WHERE 子句在什么时候变为 false。

CTE 实际成本也可能受到结果集大小的影响。生成许多行的 CTE 可能需要一个足够大的内部临时表，以便将其从内存格式转换为磁盘上的格式，这可能会降低性能。如果是这样，在内存运行的范围内，增加临时表的大小可以提高性能。

**实操：**

```sql
mysql> select * from access_log;
+-----+---------+-------+------------+
| aid | site_id | count | date       |
+-----+---------+-------+------------+
|   1 |       1 |     3 | 2016-05-10 |
|   2 |       3 |     2 | 2016-05-13 |
|   3 |       1 |     5 | 2016-05-14 |
|   4 |       2 |     4 | 2016-05-14 |
|   5 |       5 |     4 | 2016-05-14 |
+-----+---------+-------+------------+
5 rows in set (0.00 sec)

-- 递归 CTE 的子查询有两部分，由 UNION [ALL] 或 UNION DISTINCT 分隔
-- 第一个 SELECT 产生原始行，或是 CTE 的行，不会引用 CTE 名称。
-- 第一个 SELECT 产生额外的行，通过在 FROM 子句中引用 CTE 名称。当这部分不再产生新行时，递归结束。
mysql> with recursive cte as (
    -> select aid,site_id,count,date from access_log
    -> union all
    -> select aid,site_id,count+1,date from cte where count<5
    -> )
    -> select * from cte;
+------+---------+-------+------------+
| aid  | site_id | count | date       |
+------+---------+-------+------------+
|    1 |       1 |     3 | 2016-05-10 |
|    2 |       3 |     2 | 2016-05-13 |
|    3 |       1 |     5 | 2016-05-14 |
|    4 |       2 |     4 | 2016-05-14 |
|    5 |       5 |     4 | 2016-05-14 |
|    1 |       1 |     4 | 2016-05-10 |
|    2 |       3 |     3 | 2016-05-13 |
|    4 |       2 |     5 | 2016-05-14 |
|    5 |       5 |     5 | 2016-05-14 |
|    1 |       1 |     5 | 2016-05-10 |
|    2 |       3 |     4 | 2016-05-13 |
|    2 |       3 |     5 | 2016-05-13 |
+------+---------+-------+------------+
12 rows in set (0.00 sec)

mysql> with recursive cte as (
    -> select count from access_log                 
    -> union all
    -> select count+1 from cte where count<5                 
    -> )
    -> select * from cte;
+-------+
| count |
+-------+
|     3 |
|     2 |
|     5 |
|     4 |
|     4 |
|     4 |
|     3 |
|     5 |
|     5 |
|     5 |
|     4 |
|     5 |
+-------+
12 rows in set (0.00 sec)

mysql> with recursive cte as (
    -> select count from access_log 
    -> union
    -> select count+1 from cte where count<5 
    -> )
    -> select * from cte;
+-------+
| count |
+-------+
|     3 |
|     2 |
|     5 |
|     4 |
+-------+
4 rows in set (0.00 sec)

mysql> with recursive cte as (
    -> select count from access_log
    -> union distinct 
    -> select count+1 from cte where count<5
    -> )
    -> select * from cte;
+-------+
| count |
+-------+
|     3 |
|     2 |
|     5 |
|     4 |
+-------+
4 rows in set (0.00 sec)

-- 列是通过列名称而不是位置访问的，这意味着递归部分的列可以访问非递归部分中不同位置的列
mysql> with recursive cte as (
    -> select aid,site_id,count,date from access_log
    -> union all
    -> select aid,count+1 site_id,site_id+1 count,date from cte where count<5
    -> )
    -> select * from cte;
+------+---------+-------+------------+
| aid  | site_id | count | date       |
+------+---------+-------+------------+
|    1 |       1 |     3 | 2016-05-10 |
|    2 |       3 |     2 | 2016-05-13 |
|    3 |       1 |     5 | 2016-05-14 |
|    4 |       2 |     4 | 2016-05-14 |
|    5 |       5 |     4 | 2016-05-14 |
|    1 |       4 |     2 | 2016-05-10 |
|    2 |       3 |     4 | 2016-05-13 |
|    4 |       5 |     3 | 2016-05-14 |
|    5 |       5 |     6 | 2016-05-14 |
|    1 |       3 |     5 | 2016-05-10 |
|    2 |       5 |     4 | 2016-05-13 |
|    4 |       4 |     6 | 2016-05-14 |
|    2 |       5 |     6 | 2016-05-13 |
+------+---------+-------+------------+
13 rows in set (0.00 sec)

-- 递归的 SELECT 部分不能包含如下结构：
-- Aggregate functions such as SUM()Window functions
-- GROUP BY
-- ORDER BY
-- DISTINCT
mysql> with recursive cte as (
    -> select aid,site_id,count,date from access_log
    -> union all
    -> select aid,site_id,sum(count),date from cte group by aid,site_id,date
    -> )
    -> select * from cte;
ERROR 3575 (HY000): Recursive Common Table Expression 'cte' can contain neither aggregation nor window functions in recursive query block

mysql> select * from dept_emp_cte;
+--------+---------+------------+------------+
| emp_no | dept_no | from_date  | to_date    |
+--------+---------+------------+------------+
|  10001 | d001    | 1986-06-26 | 9999-01-01 |
|  10002 | d001    | 1996-08-03 | 9999-01-01 |
|  10003 | d004    | 1995-12-03 | 9999-01-01 |
+--------+---------+------------+------------+
3 rows in set (0.00 sec)

-- 如果 CTE 的递归部分比非递归部分产生更宽的列值，则可能有必要扩大非递归部分的列，以避免数据截断。
mysql> with recursive cte as (
    -> select emp_no,dept_no from dept_emp_cte
    -> union all
    -> select emp_no,concat(dept_no,'a') from cte
    -> )
    -> select * from cte;
ERROR 1406 (22001): Data too long for column 'dept_no' at row 1

mysql> with recursive cte as (
    -> select emp_no,cast(dept_no as char(10)) dept_no_new from dept_emp_cte
    -> union all
    -> select emp_no,concat(dept_no_new,'a') from cte where char_length(dept_no_new)<6
    -> )
    -> select * from cte;
+--------+-------------+
| emp_no | dept_no_new |
+--------+-------------+
|  10001 | d001        |
|  10002 | d001        |
|  10003 | d004        |
|  10001 | d001a       |
|  10002 | d001a       |
|  10003 | d004a       |
|  10001 | d001aa      |
|  10002 | d001aa      |
|  10003 | d004aa      |
+--------+-------------+
9 rows in set (0.00 sec)
```

## 4、Limiting Common Table Expression Recursion

*It is important for recursive CTEs that the recursive SELECT part include a condition to terminate recursion. As a development technique to guard against a runaway recursive CTE, you can force termination by placing a limit on execution time:*

**对于递归 CTEs ，递归 SELECT 部分必须包含终止递归的条件**，

**可以通过限制执行时间来强制终止**:

- 系统变量 `cte_max_recursion_depth` 对 CTEs 的递归次数进行限制。服务器终止递归次数超过此变量值的任何 CTE 的执行。

- 系统变量 `max_execution_time` 强制在当前会话中执行 SELECT 语句的执行超时时间。

- `MAX_EXECUTION_TIME` 优化器提示对出现它的 SELECT 语句强制执行每个查询的执行超时时间。

*The cte_max_recursion_depth system variable enforces a limit on the number of recursion levels for CTEs. The server terminates execution of any CTE that recurses more levels than the value of this variable.*

*The max_execution_time system variable enforces an execution timeout for SELECT statements executed within the current session.*

*The MAX_EXECUTION_TIME optimizer hint enforces a per-query execution timeout for the SELECT statement in which it appears.*

*Suppose that a recursive CTE is mistakenly written with no recursion execution termination condition:*

假设递归 CTE 写错了，没有递归执行终止条件:

```sql
WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte
)
SELECT * FROM cte;
```
*By default, cte_max_recursion_depth has a value of 1000, causing the CTE to terminate when it recurses past 1000 levels. Applications can change the session value to adjust for their requirements:*

**默认情况下，`cte_max_recursion_depth` 的值为 1000**，这会导致 CTE 在递归超过 1000 时终止。应用程序可以根据自己的需求改变会话值:

```sql
SET SESSION cte_max_recursion_depth = 10;      -- permit only shallow recursion
SET SESSION cte_max_recursion_depth = 1000000; -- permit deeper recursion
```

*You can also set the global cte_max_recursion_depth value to affect all sessions that begin subsequently.*

*For queries that execute and thus recurse slowly or in contexts for which there is reason to set the cte_max_recursion_depth value very high, another way to guard against deep recursion is to set a per-session timeout. To do so, execute a statement like this prior to executing the CTE statement:*

还可以**设置全局 `cte_max_recursion_depth` 值**，影响之后开始的所有会话。

对于执行缓慢且递归缓慢的查询，或者在有理由将 `cte_max_recursion_depth` 值设置得非常高的上下文中，**防止深度递归的另一种方法是设置每个会话超时时间**。

为此，在执行 CTE 语句之前执行这样的语句:

```sql
SET max_execution_time = 1000; -- impose one second timeout
```

*Alternatively, include an optimizer hint within the CTE statement itself:*

或者，**在 CTE 语句本身中包含优化器提示**:

```sql
WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte
)
SELECT /*+ SET_VAR(cte_max_recursion_depth = 1M) */ * FROM cte;

WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte
)
SELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM cte;
```

*Beginning with MySQL 8.0.19, you can also use LIMIT within the recursive query to impose a maximum nuber of rows to be returned to the outermost SELECT, for example:*

**从 MySQL 8.0.19 开始，你也可以在递归查询中使用 LIMIT 来强制设置返回到最外层 SELECT 的最大行数**，例如:

```sql
WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte LIMIT 10000
)
SELECT * FROM cte;
```

*You can do this in addition to or instead of setting a time limit. Thus, the following CTE terminates after returning ten thousand rows or running for one thousand seconds, whichever occurs first:*

除了这样做，你也可以设置时间限制。

因此，以下 CTE 在返回 10000 行或运行 1000 秒后终止，谁先发生就使用哪个条件:

```sql
WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte LIMIT 10000
)
SELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM cte;
```

*If a recursive query without an execution time limit enters an infinite loop, you can terminate it from another session using KILL QUERY. Within the session itself, the client program used to run the query might provide a way to kill the query. For example, in mysql, typing Control+C interrupts the current statement.*

如果没有执行时间限制的递归查询进入无限循环，则可以使用`KILL query` 从另一个会话终止它。

在这个会话本身中，用于运行查询的客户机程序可能提供一种终止查询的方法。例如，在 mysql 中，输入 Control+C 会中断当前语句。

```sql
mysql> select * from access_log;
+-----+---------+-------+------------+
| aid | site_id | count | date       |
+-----+---------+-------+------------+
|   1 |       1 |     3 | 2016-05-10 |
|   2 |       3 |     2 | 2016-05-13 |
|   3 |       1 |     5 | 2016-05-14 |
|   4 |       2 |     4 | 2016-05-14 |
|   5 |       5 |     4 | 2016-05-14 |
+-----+---------+-------+------------+
5 rows in set (0.00 sec)

-- 系统变量 cte_max_recursion_depth 对 CTEs 的递归次数进行限制。服务器终止递归次数超过此变量值的任何 CTE 的执行。
mysql> with recursive cte as (
    -> select aid,site_id,count,date from access_log
    -> union all
    -> select aid,site_id,count+1,date from cte
    -> )
    -> select /*+ SET_VAR(cte_max_recursion_depth = 1M) */ * from cte;
ERROR 3636 (HY000): Recursive query aborted after 1048577 iterations. Try increasing @@cte_max_recursion_depth to a larger value.

-- 设置每个会话超时时间
-- 系统变量 max_execution_time 强制在当前会话中执行 SELECT 语句的执行超时时间。
mysql> with recursive cte as (
    -> select aid,site_id,count,date from access_log
    -> union all
    -> select aid,site_id,count+1,date from cte
    -> )
    -> select /*+ MAX_EXECUTION_TIME(10) */ * from cte;   
ERROR 3024 (HY000): Query execution was interrupted, maximum statement execution time exceeded

-- 在递归查询中使用 LIMIT 来强制设置返回到最外层 SELECT 的最大行数
mysql> with recursive cte as (
    -> select aid,site_id,count,date from access_log
    -> union all
    -> select aid,site_id,count+1,date from cte LIMIT 10
    -> )
    -> select * from cte;                              
+------+---------+-------+------------+
| aid  | site_id | count | date       |
+------+---------+-------+------------+
|    1 |       1 |     3 | 2016-05-10 |
|    2 |       3 |     2 | 2016-05-13 |
|    3 |       1 |     5 | 2016-05-14 |
|    4 |       2 |     4 | 2016-05-14 |
|    5 |       5 |     4 | 2016-05-14 |
|    1 |       1 |     4 | 2016-05-10 |
|    2 |       3 |     3 | 2016-05-13 |
|    3 |       1 |     6 | 2016-05-14 |
|    4 |       2 |     5 | 2016-05-14 |
|    5 |       5 |     5 | 2016-05-14 |
+------+---------+-------+------------+
10 rows in set (0.00 sec)
```

## 5、Recursive Common Table Expression Examples

As mentioned previously, recursive common table expressions (CTEs) are frequently used for **series generation and traversing hierarchical or tree-structured data**. This section shows some simple examples of these techniques.

- Fibonacci Series Generation

- Date Series Generation

- Hierarchical Data Traversal

### 5.1、Fibonacci Series Generation

*A Fibonacci series begins with the two numbers 0 and 1 (or 1 and 1) and each number after that is the sum of the previous two numbers. A recursive common table expression can generate a Fibonacci series if each row produced by the recursive SELECT has access to the two previous numbers from the series. The following CTE generates a 10-number series using 0 and 1 as the first two numbers:*

如果由递归的 SELECT 生成的每行可以访问前两个数字，就可以生成斐波那契额数列。

```sql
WITH RECURSIVE fibonacci (n, fib_n, next_fib_n) AS
(
  SELECT 1, 0, 1
  UNION ALL
  SELECT n + 1, next_fib_n, fib_n + next_fib_n
    FROM fibonacci WHERE n < 10
)
SELECT * FROM fibonacci;
```

*The CTE produces this result:*

    +------+-------+------------+
    | n    | fib_n | next_fib_n |
    +------+-------+------------+
    |    1 |     0 |          1 |
    |    2 |     1 |          1 |
    |    3 |     1 |          2 |
    |    4 |     2 |          3 |
    |    5 |     3 |          5 |
    |    6 |     5 |          8 |
    |    7 |     8 |         13 |
    |    8 |    13 |         21 |
    |    9 |    21 |         34 |
    |   10 |    34 |         55 |
    +------+-------+------------+

How the CTE works:

- n 是一个显示列，表示该行包含第 n 个斐波那契数。例如，第 8 个斐波那契数字是 13。

- fib_n 列显示斐波那契数 n。

- next_fib_n 列显示数字 n 之后的下一个斐波那契数。该列为下一行提供下一个级数值，以便该行可以在其 fib_n 列中生成前两个级数值的和。

- 当 n 达到10时，递归结束。这是一种随意的选择，将输出限制为一小组行。

*n is a display column to indicate that the row contains the n-th Fibonacci number. For example, the 8th Fibonacci number is 13.*

*The fib_n column displays Fibonacci number n.*

*The next_fib_n column displays the next Fibonacci number after number n. This column provides the next series value to the next row, so that row can produce the sum of the two previous series values in its fib_n column.*

*Recursion ends when n reaches 10. This is an arbitrary choice, to limit the output to a small set of rows.*

*The preceding output shows the entire CTE result. To select just part of it, add an appropriate WHERE clause to the top-level SELECT. For example, to select the 8th Fibonacci number, do this:*

前面的输出显示了整个 CTE 结果。若要只选择其中的一部分，请在顶层 SELECT 中添加适当的 WHERE 子句。例如，要选择第 8 个斐波那契数，这样做:

```sql
mysql> WITH RECURSIVE fibonacci ...
       ...
       SELECT fib_n FROM fibonacci WHERE n = 8;
+-------+
| fib_n |
+-------+
|    13 |
+-------+
```

### 5.2、Date Series Generation

*A common table expression can generate a series of successive dates, which is useful for generating summaries that include a row for all dates in the series, including dates not represented in the summarized data.*

*Suppose that a table of sales numbers contains these rows:*

CTE 可以生成一系列连续的日期，这对于生成包含系列中所有日期(包括汇总数据中未表示的日期)的摘要非常有用。

假设一个销售数字表包含以下行：

```sql
mysql> SELECT * FROM sales ORDER BY date, price;
+------------+--------+
| date       | price  |
+------------+--------+
| 2017-01-03 | 100.00 |
| 2017-01-03 | 200.00 |
| 2017-01-06 |  50.00 |
| 2017-01-08 |  10.00 |
| 2017-01-08 |  20.00 |
| 2017-01-08 | 150.00 |
| 2017-01-10 |   5.00 |
+------------+--------+
```

This query summarizes the sales per day:

```sql
mysql> SELECT date, SUM(price) AS sum_price
       FROM sales
       GROUP BY date
       ORDER BY date;
+------------+-----------+
| date       | sum_price |
+------------+-----------+
| 2017-01-03 |    300.00 |
| 2017-01-06 |     50.00 |
| 2017-01-08 |    180.00 |
| 2017-01-10 |      5.00 |
+------------+-----------+
```

*However, that result contains “holes” for dates not represented in the range of dates spanned by the table. A result that represents all dates in the range can be produced using a recursive CTE to generate that set of dates, joined with a LEFT JOIN to the sales data.*

*Here is the CTE to generate the date range series:*

但是，该结果的日期不连续。

可以使用递 CTE 生成范围内所有日期的结果，以生成该日期集，并 LEFT JOIN 销售数据。

这是生成日期范围系列的 CTE：

```sql
WITH RECURSIVE dates (date) AS
(
  SELECT MIN(date) FROM sales
  UNION ALL
  SELECT date + INTERVAL 1 DAY FROM dates
  WHERE date + INTERVAL 1 DAY <= (SELECT MAX(date) FROM sales)
)
SELECT * FROM dates;
```

The CTE produces this result:

    +------------+
    | date       |
    +------------+
    | 2017-01-03 |
    | 2017-01-04 |
    | 2017-01-05 |
    | 2017-01-06 |
    | 2017-01-07 |
    | 2017-01-08 |
    | 2017-01-09 |
    | 2017-01-10 |
    +------------+

How the CTE works:

- 非递归 SELECT 生成 sales 表日期范围的最小日期。

- 递归 SELECT 生成的每一行都会向前一行生成的日期添加一天。

- 在日期达到 sales 表所跨越的日期范围中的最高日期后，递归结束。

*The nonrecursive SELECT produces the lowest date in the date range spanned by the sales table.*

*Each row produced by the recursive SELECT adds one day to the date produced by the previous row.*

*Recursion ends after the dates reach the highest date in the date range spanned by the sales table.*

*Joining the CTE with a LEFT JOIN against the sales table produces the sales summary with a row for each date in the range:*

将 CTE LEFT JOIN sales 表，生成范围内每个日期的销售摘要：

```sql
WITH RECURSIVE dates (date) AS
(
  SELECT MIN(date) FROM sales
  UNION ALL
  SELECT date + INTERVAL 1 DAY FROM dates
  WHERE date + INTERVAL 1 DAY <= (SELECT MAX(date) FROM sales)
)
SELECT dates.date, COALESCE(SUM(price), 0) AS sum_price
FROM dates LEFT JOIN sales ON dates.date = sales.date
GROUP BY dates.date
ORDER BY dates.date;
```

*The output looks like this:*

    +------------+-----------+
    | date       | sum_price |
    +------------+-----------+
    | 2017-01-03 |    300.00 |
    | 2017-01-04 |      0.00 |
    | 2017-01-05 |      0.00 |
    | 2017-01-06 |     50.00 |
    | 2017-01-07 |      0.00 |
    | 2017-01-08 |    180.00 |
    | 2017-01-09 |      0.00 |
    | 2017-01-10 |      5.00 |
    +------------+-----------+

需要注意的点:

- 查询效率低吗，特别是对于递归 SELECT 中的执行 MAX() 函数的每一行的子查询？EXPLAIN 表明包含 MAX() 的子查询只计算一次，并且缓存结果。

- COALESCE() 的使用避免了在 sales 表中没有出现销售数据的日期里，在 sum_price 列中显示 NULL。

*Are the queries inefficient, particularly the one with the MAX() subquery executed for each row in the recursive SELECT? EXPLAIN shows that the subquery containing MAX() is evaluated only once and the result is cached.*

*The use of COALESCE() avoids displaying NULL in the sum_price column on days for which no sales data occur in the sales table.*

### 5.3、Hierarchical Data Traversal

*Recursive common table expressions are useful for traversing data that forms a hierarchy. Consider these statements that create a small data set that shows, for each employee in a company, the employee name and ID number, and the ID of the employee's manager. The top-level employee (the CEO), has a manager ID of NULL (no manager).*

递归 CTE 对于遍历层次结构的数据非常有用。

考虑一下这些语句，它们创建了一个小数据集，对公司中的每个员工，显示员工姓名和ID号，以及员工经理的 ID。顶级员工(CEO)的经理ID为NULL(没有经理)。

```sql
CREATE TABLE employees (
  id         INT PRIMARY KEY NOT NULL,
  name       VARCHAR(100) NOT NULL,
  manager_id INT NULL,
  INDEX (manager_id),
FOREIGN KEY (manager_id) REFERENCES employees (id)
);
INSERT INTO employees VALUES
(333, "Yasmina", NULL),  # Yasmina is the CEO (manager_id is NULL)
(198, "John", 333),      # John has ID 198 and reports to 333 (Yasmina)
(692, "Tarek", 333),
(29, "Pedro", 198),
(4610, "Sarah", 29),
(72, "Pierre", 29),
(123, "Adil", 692);
```

*The resulting data set looks like this:*

```sql
mysql> SELECT * FROM employees ORDER BY id;
+------+---------+------------+
| id   | name    | manager_id |
+------+---------+------------+
|   29 | Pedro   |        198 |
|   72 | Pierre  |         29 |
|  123 | Adil    |        692 |
|  198 | John    |        333 |
|  333 | Yasmina |       NULL |
|  692 | Tarek   |        333 |
| 4610 | Sarah   |         29 |
+------+---------+------------+
```

*To produce the organizational chart with the management chain for each employee (that is, the path from CEO to employee), use a recursive CTE:*

为了生成每个员工的管理链(即从CEO到员工的路径)的组织结构图，使用递归 CTE:

```sql
WITH RECURSIVE employee_paths (id, name, path) AS
(
  SELECT id, name, CAST(id AS CHAR(200))
    FROM employees
    WHERE manager_id IS NULL
  UNION ALL
  SELECT e.id, e.name, CONCAT(ep.path, ',', e.id)
    FROM employee_paths AS ep JOIN employees AS e
      ON ep.id = e.manager_id
)
SELECT * FROM employee_paths ORDER BY path;
```

The CTE produces this output:

    +------+---------+-----------------+
    | id   | name    | path            |
    +------+---------+-----------------+
    |  333 | Yasmina | 333             |
    |  198 | John    | 333,198         |
    |   29 | Pedro   | 333,198,29      |
    | 4610 | Sarah   | 333,198,29,4610 |
    |   72 | Pierre  | 333,198,29,72   |
    |  692 | Tarek   | 333,692         |
    |  123 | Adil    | 333,692,123     |
    +------+---------+-----------------+

How the CTE works:

- 非递归 SELECT 生成 CEO 的行(manager ID 为 NULL 的行)。

- path 列被扩展为 CHAR(200)，以确保有空间用于递归 SELECT 产生的更长的路径值。

- 递归 SELECT 生成的每一行查找直接向前一行生成的员工报告的所有员工。对于每个这样的员工，该行包括员工 ID 和姓名以及员工管理链。该链是经理链，员工ID添加到末端。

- 当员工没有其他人向他们报告时，递归结束。

*The nonrecursive SELECT produces the row for the CEO (the row with a NULL manager ID).*

*The path column is widened to CHAR(200) to ensure that there is room for the longer path values produced by the recursive SELECT.*

*Each row produced by the recursive SELECT finds all employees who report directly to an employee produced by a previous row. For each such employee, the row includes the employee ID and name, and the employee management chain. The chain is the manager's chain, with the employee ID added to the end.*

*Recursion ends when employees have no others who report to them.*

*To find the path for a specific employee or employees, add a WHERE clause to the top-level SELECT. For example, to display the results for Tarek and Sarah, modify that SELECT like this:*

要查找某个或多个特定员工的路径，请在顶层 SELECT 中添加 WHERE 子句。例如，要显示 Tarek 和 Sarah 的结果，如下所示修改选择:

```sql
mysql> WITH RECURSIVE ...
       ...
       SELECT * FROM employees_extended
       WHERE id IN (692, 4610)
       ORDER BY path;
+------+-------+-----------------+
| id   | name  | path            |
+------+-------+-----------------+
| 4610 | Sarah | 333,198,29,4610 |
|  692 | Tarek | 333,692         |
+------+-------+-----------------+
```

## 6、Common Table Expressions Compared to Similar Constructs

*Common table expressions (CTEs) are similar to derived tables in some ways:*

CTEs 和派生表有相似之处：

- 这两个构造都被命名。

- 这两种构造都适用于一条语句的范围。

*Both constructs are named.*

*Both constructs exist for the scope of a single statement.*

*Because of these similarities, CTEs and derived tables often can be used interchangeably. As a trivial example, these statements are equivalent:*

由于这些相似之处，CTEs 和派生表通常可以互换使用。作为一个简单的例子，这些语句是等价的:

```sql
WITH cte AS (SELECT 1) SELECT * FROM cte;
SELECT * FROM (SELECT 1) AS dt;
```

*However, CTEs have some advantages over derived tables:*

*A derived table can be referenced only a single time within a query. A CTE can be referenced multiple times. To use multiple instances of a derived table result, you must derive the result multiple times.*

*A CTE can be self-referencing (recursive).*

*One CTE can refer to another.*

*A CTE may be easier to read when its definition appears at the beginning of the statement rather than embedded within it.*

*CTEs are similar to tables created with CREATE [TEMPORARY] TABLE but need not be defined or dropped explicitly. For a CTE, you need no privileges to create tables.*

然而，CTEs 比派生表有一些优势:

- 派生表在查询中只能被引用一次。CTE 可以被多次引用。若要使用派生表结果的多个实例，则必须派生该结果多次。

- CTE 可以是自引用的(递归的)。

- 一个 CTE 可以引用另一个 CTE。

- 当 CTE 的定义出现在语句的开头而不是嵌入其中时，它可能更容易阅读。

CTEs 类似于用 CREATE [TEMPORARY] 表创建的表，但不需要显式地定义或删除。对 CTE，创建表不需要授权。