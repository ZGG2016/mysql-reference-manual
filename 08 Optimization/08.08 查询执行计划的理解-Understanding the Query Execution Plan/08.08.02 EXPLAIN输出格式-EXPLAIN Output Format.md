# 08.08.02 EXPLAIN Output Format

[TOC]

> The [EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/explain.html) statement provides information about how MySQL executes statements. [EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/explain.html) works with [SELECT](https://dev.mysql.com/doc/refman/8.0/en/select.html), [DELETE](https://dev.mysql.com/doc/refman/8.0/en/delete.html), [INSERT](https://dev.mysql.com/doc/refman/8.0/en/insert.html), [REPLACE](https://dev.mysql.com/doc/refman/8.0/en/replace.html), and [UPDATE](https://dev.mysql.com/doc/refman/8.0/en/update.html) statements.

EXPLAIN 提供了 MySQL 如何执行语句的信息。可以和 SELECT、DELETE、 INSERT、REPLACE 和 UPDATE 语句一起使用。

> EXPLAIN returns a row of information for each table used in the SELECT statement. It lists the tables in the output in the order that MySQL would read them while processing the statement. This means that MySQL reads a row from the first table, then finds a matching row in the second table, and then in the third table, and so on. When all tables are processed, MySQL outputs the selected columns and backtracks through the table list until a table is found for which there are more matching rows. The next row is read from this table and the process continues with the next table.

EXPLAIN 返回 SELECT 语句中每个表的一行信息。

为了在处理语句时，MySQL 能读取它们，它在输出中列出表。这就意味着 MySQL 从第一个表中读取一行，然后在第二个表中找到匹配的一行，之后在第三个表中，等等。

当所有的表都被处理了，MySQL 输出选定的列，并通过表列表回溯，直到找到一个有更多匹配行的表。从该表读取下一行，然后继续对下一个表进行处理。

> Note:MySQL Workbench has a Visual Explain capability that provides a visual representation of EXPLAIN output. See [Tutorial: Using Explain to Improve Query Performance](https://dev.mysql.com/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html).

> 注意：MySQL 工作台有一个可视化的 EXPLAIN 功能，它提供了 EXPLAIN 输出的可视化表示。

## 1、EXPLAIN Output Columns

> This section describes the output columns produced by EXPLAIN. Later sections provide additional information about the type and Extra columns.

这部分描述 EXPLAIN 的输出列。后面的部分提供了对 type 和 Extra 列的额外信息。

> Each output row from EXPLAIN provides information about one table. Each row contains the values summarized in [Table 8.1, “EXPLAIN Output Columns”](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-output-column-table), and described in more detail following the table. Column names are shown in the table's first column; the second column provides the equivalent property name shown in the output when FORMAT=JSON is used.

EXPLAIN 输出的每一行都提供了关于一个表的信息。每行包含了 `Table 8.1, “EXPLAIN Output Columns”` 中总结的值，并在该表后面进行更详细的描述。

列名显示在表的第一列中；当使用 `FORMAT=JSON ` 时，第二列提供了使输出中显示的等效属性名。

>> Table 8.1 EXPLAIN Output Columns

Column | JSON Name | Meaning
---|:---|:---
id | select_id | The SELECT identifier
select_type | None | The SELECT type
table | table_name | The table for the output row
partitions | partitions | The matching partitions
type | access_type | The join type
possible_keys | possible_keys | The possible indexes to choose
key | key | The index actually chosen
key_len | key_length | The length of the chosen key
ref | ref | The columns compared to the index
rows | rows | Estimate of rows to be examined
filtered | filtered | Percentage of rows filtered by table condition
Extra | None | Additional information

Note:JSON properties which are NULL are not displayed in JSON-formatted EXPLAIN output.

- id (JSON name: select_id)

SELECT 标识符。这是查询中 SELECT 的序列号。如果行引用了其他行的 union 结果，则值可以为 NULL。

在本例中，表的列显示了一个类似于 `<unionM,N>` 的值，表示该行引用了 id 值为 M 和 N 的行的 union 结果。

> The SELECT identifier. This is the sequential number of the SELECT within the query. The value can be NULL if the row refers to the union result of other rows. In this case, the table column shows a value like <unionM,N> to indicate that the row refers to the union of the rows with id values of M and N.

- select_type (JSON name: none)

**SELECT 的类型**，可以是下表中的任一一个。

除非SELECT 的类型是 SIMPLE 或 PRIMARY ，否则 JSON-formatted EXPLAIN 将 SELECT 类型作为 query_block 的属性。表格中还显示了 JSON 名称(如果适用)。

> The type of SELECT, which can be any of those shown in the following table. A JSON-formatted EXPLAIN exposes the SELECT type as a property of a query_block, unless it is SIMPLE or PRIMARY. The JSON names (where applicable) are also shown in the table.

select_type Value | JSON Name | Meaning
---|:---|:---
SIMPLE | None | Simple SELECT (not using UNION or subqueries)
PRIMARY | None | Outermost SELECT
UNION | None | Second or later SELECT statement in a [UNION](https://dev.mysql.com/doc/refman/8.0/en/union.html)
DEPENDENT UNION | dependent (true) | Second or later SELECT statement in a UNION, dependent on outer query
UNION RESULT | union_result | Result of a UNION.
SUBQUERY | None | First SELECT in subquery
DEPENDENT SUBQUERY | dependent (true) | First SELECT in subquery, dependent on outer query
DERIVED | None | Derived table
DEPENDENT DERIVED | dependent (true) | Derived table dependent on another table
MATERIALIZED | materialized_from_subquery | Materialized subquery
UNCACHEABLE SUBQUERY | cacheable (false) | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query
UNCACHEABLE UNION | cacheable (false) | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)

DEPENDENT 通常表示相关子查询的使用。

> DEPENDENT typically signifies the use of a correlated subquery. See [Section 13.2.11.7, “Correlated Subqueries”](https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html).

DEPENDENT SUBQUERY 不同于 UNCACHEABLE SUBQUERY 的计算。

  对于 DEPENDENT SUBQUERY，对外部环境的变量的每一组不同值，子查询只重新计算一次。

  对于 UNCACHEABLE SUBQUERY，对外部环境的每一行，子查询会重新计算。

> DEPENDENT SUBQUERY evaluation differs from UNCACHEABLE SUBQUERY evaluation. For DEPENDENT SUBQUERY, the subquery is re-evaluated only once for each set of different values of the variables from its outer context. For UNCACHEABLE SUBQUERY, the subquery is re-evaluated for each row of the outer context.

当你使用 EXPLAIN 指定了 `FORMAT=JSON` 时，输出没有直接等同于 select_type 的单一属性；query_block 属性对应于给定的 SELECT。

与刚才显示的，和大多数 SELECT 子查询类型等价的属性是可用的(例如对于 MATERIALIZED 的 being materialized_from_subquery)，并在适当的时候显示。

对于 SIMPLE 或 PRIMARY，没有对应的 JSON。

> When you specify FORMAT=JSON with EXPLAIN, the output has no single property directly equivalent to select_type; the query_block property corresponds to a given SELECT. Properties equivalent to most of the SELECT subquery types just shown are available (an example being materialized_from_subquery for MATERIALIZED), and are displayed when appropriate. There are no JSON equivalents for SIMPLE or PRIMARY.

非 SELECT 语句的 select_type 值展示受影响表的语句类型。例如，对 DELETE 语句，select_type 是 DELETE。

> The select_type value for non-SELECT statements displays the statement type for affected tables. For example, select_type is DELETE for DELETE statements.

- table (JSON name: table_name)

输出行引用的表的名字。可以是下列中的一个：

`<unionM,N>`：行引用的是 id 为 M 和 N 的行的 union。

`<derivedN>`：行引用的是 id 值为 N 的行的派生表结果。例如，派生表可能来自 FROM 子句中的子查询。

`<subqueryN>`：行引用的是 id 值为 N 的行的物化子查询的结果。

> The name of the table to which the row of output refers. This can also be one of the following values:

> <unionM,N>: The row refers to the union of the rows with id values of M and N.

> <derivedN>: The row refers to the derived table result for the row with an id value of N. A derived table may result, for example, from a subquery in the FROM clause.

> <subqueryN>: The row refers to the result of a materialized subquery for the row with an id value of N. See [Section 8.2.2.2, “Optimizing Subqueries with Materialization”](https://dev.mysql.com/doc/refman/8.0/en/subquery-materialization.html).

- partitions (JSON name: partitions)

查询将从哪些分区匹配记录。对于非分区表，该值为 NULL。

> The partitions from which records would be matched by the query. The value is NULL for nonpartitioned tables. See [Section 24.3.5, “Obtaining Information About Partitions”](https://dev.mysql.com/doc/refman/8.0/en/partitioning-info.html).

- type (JSON name: access_type)

join 的类型。

> The join type. For descriptions of the different types, see EXPLAIN [Join Types](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types).

- possible_keys (JSON name: possible_keys)

`possible_keys` 表示 MySQL 在表中查找行时可以选择使用的索引。

注意，此列完全独立于 EXPLAIN 输出表的顺序。

这意味着，对于生成的表顺序，possible_keys 中的一些键可能在实践中是不可用的。

> The possible_keys column indicates the indexes from which MySQL can choose to find the rows in this table. Note that this column is totally independent of the order of the tables as displayed in the output from EXPLAIN. That means that some of the keys in possible_keys might not be usable in practice with the generated table order.

如果该列为 NULL(或在 JSON-formatted 的输出中未定义)，则没有相关索引。

在这种情况下，你可以通过检查 WHERE 子句，来检查它是否引用了某些列或适合建立索引的列，从而提高查询的性能。

如果是，则创建适当的索引，并再次使用 EXPLAIN 检查查询。

> If this column is NULL (or undefined in JSON-formatted output), there are no relevant indexes. In this case, you may be able to improve the performance of your query by examining the WHERE clause to check whether it refers to some column or columns that would be suitable for indexing. If so, create an appropriate index and check the query with EXPLAIN again. See [Section 13.1.9, “ALTER TABLE Statement”](https://dev.mysql.com/doc/refman/8.0/en/alter-table.html).

要查看表具有哪些索引，请使用`SHOW INDEX FROM tbl_name`

> To see what indexes a table has, use SHOW INDEX FROM tbl_name.

- key (JSON name: key)

key 列表示 MySQL 实际决定使用的键(索引)。

如果 MySQL 决定使用一个 possible_keys 中的索引来查找行，那么这个索引被作为键值形式列出。

> The key column indicates the key (index) that MySQL actually decided to use. If MySQL decides to use one of the possible_keys indexes to look up rows, that index is listed as the key value.

key 可能会命名一个没有出现在 possible_keys 中的索引。如果 possible_keys 的所有的索引都不适合查找行，但是查询选择的所有列有其他索引，那么就会发生这种情况。

也就是说，命名索引覆盖选定的列，因此尽管它不用于确定要检索哪些行，但扫描索引比扫描数据行更有效。

> It is possible that key may name an index that is not present in the possible_keys value. This can happen if none of the possible_keys indexes are suitable for looking up rows, but all the columns selected by the query are columns of some other index. That is, the named index covers the selected columns, so although it is not used to determine which rows to retrieve, an index scan is more efficient than a data row scan.

对于 InnoDB，即使查询也选择了主键列，一个二级索引可能会覆盖所选的列，因为 InnoDB 将主键值存储在每个辅助索引中【？？】。如果键是 NULL, MySQL 发现没有用于更有效地执行查询的索引。

>  [InnoDB](https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html), a secondary index might cover the selected columns even if the query also selects the primary key because InnoDB stores the primary key value with each secondary index. If key is NULL, MySQL found no index to use for executing the query more efficiently.

要强制使用或忽略在 possible_keys 列中列出的索引，可以在查询中使用`FORCE INDEX`、`USE INDEX`、`IGNORE INDEX`。

> To force MySQL to use or ignore an index listed in the possible_keys column, use FORCE INDEX, USE INDEX, or IGNORE INDEX in your query. See [Section 8.9.4, “Index Hints”](https://dev.mysql.com/doc/refman/8.0/en/index-hints.html).

对于 MyISAM 表，运行`ANALYZE TABLE`有助于优化器选择更好的索引。对于 MyISAM表 ，`myisamchk——analyze`做同样的事情。

> For MyISAM tables, running [ANALYZE TABLE](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html) helps the optimizer choose better indexes. For MyISAM tables, [myisamchk --analyze](https://dev.mysql.com/doc/refman/8.0/en/myisamchk.html) does the same. See [Section 13.7.3.1, “ANALYZE TABLE Statement”](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html), and [Section 7.6, “MyISAM Table Maintenance and Crash Recovery”](https://dev.mysql.com/doc/refman/8.0/en/myisam-table-maintenance.html).

- key_len (JSON name: key_length)

key_len 列表示 MySQL 决定使用的键的长度。

key_len 的值决定 MySQL 实际使用了多少个 multiple-part 键。如果键列是 NULL, key_len 列也是 NULL。

> The key_len column indicates the length of the key that MySQL decided to use. The value of key_len enables you to determine how many parts of a multiple-part key MySQL actually uses. If the key column says NULL, the key_len column also says NULL.

由于使用 key 存储格式，空列的 key 长度要比非空列的长度大 1。

> Due to the key storage format, the key length is one greater for a column that can be NULL than for a NOT NULL column.

- ref (JSON name: ref)

ref 列表示将哪些列或常量与 key 列中命名的索引进行比较，以便从表中选择行。

> The ref column shows which columns or constants are compared to the index named in the key column to select rows from the table.

如果值是 func，则使用的值是某个函数的结果。要查看是哪个函数，请在 EXPLAIN 后面使用 `SHOW WARNINGS` 来查看扩展的 EXPLAIN 输出。函数实际上可能是一个运算符，比如算术运算符。

> If the value is func, the value used is the result of some function. To see which function, use [SHOW WARNINGS](https://dev.mysql.com/doc/refman/8.0/en/show-warnings.html) following EXPLAIN to see the extended EXPLAIN output. The function might actually be an operator such as an arithmetic operator.

- rows (JSON name: rows)

rows 列表示 MySQL 为执行查询必须检查的行数。

> The rows column indicates the number of rows MySQL believes it must examine to execute the query.

对于 InnoDB 表，这个数字只是一个估计值，可能并不总是准确的。

> For InnoDB tables, this number is an estimate, and may not always be exact.

- filtered (JSON name: filtered)

filtered 列表示表条件筛选的行的估计百分比。

最大值是100，这意味着没有对行进行过滤。值从100减少表示过滤的次数增加。

rows 表示估计的检查行数，`rows×filtered` 表示与下表 join 的行数。例如，如果行数为 1000，过滤值为 50.00(50%)，则与下表 join 的行数为 1000×50% = 500。

> The filtered column indicates an estimated percentage of table rows that are filtered by the table condition. The maximum value is 100, which means no filtering of rows occurred. Values decreasing from 100 indicate increasing amounts of filtering. rows shows the estimated number of rows examined and rows × filtered shows the number of rows that are joined with the following table. For example, if rows is 1000 and filtered is 50.00 (50%), the number of rows to be joined with the following table is 1000 × 50% = 500.

- Extra (JSON name: none)

此列包含关于 MySQL 如何解析查询的附加信息。

> This column contains additional information about how MySQL resolves the query. For descriptions of the different values, see EXPLAIN [Extra Information](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information).

没有单独的 JSON 属性对应于 Extra 列；但是，可以在此列中出现的值将作为 JSON 属性或消息属性的文本公开。

> There is no single JSON property corresponding to the Extra column; however, values that can occur in this column are exposed as JSON properties, or as the text of the message property.

## 2、EXPLAIN Join Types

EXPLAIN 输出的 `type` 列描述了表如何 join 的。在 JSON-formatted 输出中，是 access_type 属性值。

下面就列出了 join 的类型，按照从最后到最差的顺序：

> The type column of EXPLAIN output describes how tables are joined. In JSON-formatted output, these are found as values of the access_type property. The following list describes the join types, ordered from the best type to the worst:

- system

表只有一行(= system table)。是 `const` join 的特殊情况。

> The table has only one row (= system table). This is a special case of the const join type.

- const

该表最多有一个匹配行，在查询开始时读取。

因为只有一行，所以优化器的其余部分可以将这一行中列的值视为常量。const 表非常快，因为它们只读取一次。

> The table has at most one matching row, which is read at the start of the query. Because there is only one row, values from the column in this row can be regarded as constants by the rest of the optimizer. const tables are very fast because they are read only once.

> const is used when you compare all parts of a PRIMARY KEY or UNIQUE index to constant values. In the following queries, tbl_name can be used as a const table:

当将 PRIMARY KEY 或 UNIQUE index 的所有部分与常量值进行比较时，将使用 const。在以下查询中，可以使用 tbl_name 作为 const 表:

```sql
SELECT * FROM tbl_name WHERE primary_key=1;

SELECT * FROM tbl_name
  WHERE primary_key_part1=1 AND primary_key_part2=2;
```

- eq_ref

One row is read from this table for each combination of rows from the previous tables.

除了 `system` 和 `const` 类型之外，这是最可能的 join 类型。

当 join 使用索引的所有部分，并且索引是 PRIMARY KEY 或 UNIQUE NOT NULL index 时，将使用它。

> One row is read from this table for each combination of rows from the previous tables. Other than the system and const types, this is the best possible join type. It is used when all parts of an index are used by the join and the index is a PRIMARY KEY or UNIQUE NOT NULL index.

> eq_ref can be used for indexed columns that are compared using the = operator. The comparison value can be a constant or an expression that uses columns from tables that are read before this table. In the following examples, MySQL can use an eq_ref join to process ref_table:

eq_ref 可用于使用 `=` 操作符进行比较的索引列。比较值可以是一个常量或一个表达式，该表达式使用在该表之前读取的表中的列。

在下面的例子中，MySQL 可以使用 eq_ref join 来处理 ref_table:

```sql
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;

SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
  AND ref_table.key_column_part2=1;
```

- ref

对于前一个表中的每个行组合，从这个表中读取索引匹配的所有行。

如果 join 仅使用 KEY 的最左前缀，或者 KEY 不是 PRIMARY KEY 或 UNIQUE index(换句话说，如果 join 不能根据键值选择单行)，则使用 ref。如果所使用的 KEY 只匹配几行，那么这是一种很好的 join 类型。

> All rows with matching index values are read from this table for each combination of rows from the previous tables. ref is used if the join uses only a leftmost prefix of the key or if the key is not a PRIMARY KEY or UNIQUE index (in other words, if the join cannot select a single row based on the key value). If the key that is used matches only a few rows, this is a good join type.

> ref can be used for indexed columns that are compared using the = or <=> operator. In the following examples, MySQL can use a ref join to process ref_table:

ref 可用于使用 `=` 或 `<=>` 操作符进行比较的索引列。

在下面的例子中，MySQL 可以使用 ref join 来处理 ref_table:

```sql
SELECT * FROM ref_table WHERE key_column=expr;

SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;

SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
  AND ref_table.key_column_part2=1;
```

- fulltext

使用 FULLTEXT index 执行 join。

> The join is performed using a FULLTEXT index.

- ref_or_null

这个 join 类型类似于 ref，但是 MySQL 会对包含 NULL 的行进行额外的搜索。

这种 join 类型优化最常用于解析子查询。

> This join type is like ref, but with the addition that MySQL does an extra search for rows that contain NULL values. This join type optimization is used most often in resolving subqueries. In the following examples, MySQL can use a ref_or_null join to process ref_table:

在下面的例子中，MySQL 可以使用 ref_or_null join 来处理 ref_table:

```sql
SELECT * FROM ref_table
  WHERE key_column=expr OR key_column IS NULL;
```

> See [Section 8.2.1.15, “IS NULL Optimization”](https://dev.mysql.com/doc/refman/8.0/en/is-null-optimization.html).

- index_merge

此 join 类型表示使用 Index Merge 优化器。

在本例中，输出行中的 key 列包含所使用的索引列表，而 key_len 包含所使用索引的最长 key 部分的列表。

This join type indicates that the Index Merge optimization is used. In this case, the key column in the output row contains a list of indexes used, and key_len contains a list of the longest key parts for the indexes used. For more information, see [Section 8.2.1.3, “Index Merge Optimization”](https://dev.mysql.com/doc/refman/8.0/en/is-null-optimization.html).

- unique_subquery

对于一些如下的 IN 子查询，这个类型会取代 eq_ref：

> This type replaces eq_ref for some IN subqueries of the following form:

```sql
value IN (SELECT primary_key FROM single_table WHERE some_expr)
```

unique_subquery 只是一个索引查找函数，它完全替换子查询，以提高效率。

> unique_subquery is just an index lookup function that replaces the subquery completely for better efficiency.

- index_subquery

这个 join 类型类似于 unique_subquery。它取代 IN 子查询，但是适合 nonunique indexes 的子查询：

> This join type is similar to unique_subquery. It replaces IN subqueries, but it works for nonunique indexes in subqueries of the following form:

```sql
value IN (SELECT key_column FROM single_table WHERE some_expr)
```

- range

只检索给定范围内的行，使用索引选择这些行。

输出行中的 key 列表示使用哪个索引。

key_len 包含所使用的最长 key 部分。对于此类型，ref 列为 NULL。

> Only rows that are in a given range are retrieved, using an index to select the rows. The key column in the output row indicates which index is used. The key_len contains the longest key part that was used. The ref column is NULL for this type.

> range can be used when a key column is compared to a constant using any of the =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, LIKE, or IN() operators:

当 key 列使用 `=, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, LIKE, IN()` 操作符和一个常量比较时，使用 range：

```sql
SELECT * FROM tbl_name
  WHERE key_column = 10;

SELECT * FROM tbl_name
  WHERE key_column BETWEEN 10 and 20;

SELECT * FROM tbl_name
  WHERE key_column IN (10,20,30);

SELECT * FROM tbl_name
  WHERE key_part1 = 10 AND key_part2 IN (10,20,30);
```

- index

除了要扫描索引树之外，索引 join 类型与 ALL 相同。这有两种方式:

(1)如果索引是覆盖索引，并且可以用于满足表中所需的所有数据，则只扫描索引树。在本例中， Extra 列表示 `Using index`。仅索引扫描通常比 ALL 更快，因为索引的大小通常小于表数据的大小。

(2)使用从索引读取数据来执行全表扫描，以按照索引顺序查找数据行。`Uses index`不会出现在 Extra 列中。

> The index join type is the same as ALL, except that the index tree is scanned. This occurs two ways:

> If the index is a covering index for the queries and can be used to satisfy all data required from the table, only the index tree is scanned. In this case, the Extra column says Using index. An index-only scan usually is faster than ALL because the size of the index usually is smaller than the table data.

> A full table scan is performed using reads from the index to look up data rows in index order. Uses index does not appear in the Extra column.

当查询只使用属于单个索引的列时，MySQL可以使用此 join 类型。

> MySQL can use this join type when the query uses only columns that are part of a single index.

- ALL

对前一个表中的每个行组合进行全表扫描。

如果表是没有标记为 const 的第一个表，这通常不好。在所有其他情况下通常非常糟糕。

通常，可以通过添加索引来避免 ALL，这些索引允许根据常量值或前面表中的列值从表中检索行。

> A full table scan is done for each combination of rows from the previous tables. This is normally not good if the table is the first table not marked const, and usually very bad in all other cases. Normally, you can avoid ALL by adding indexes that enable row retrieval from the table based on constant values or column values from earlier tables.

## 3、EXPLAIN Extra Information

EXPLAIN 输出的 Extra 列包含关于MySQL如何解析查询的额外信息。

下面的列表解释了出现在此列中的值。

每项表示了，对于 JSON-formatted 的输出，哪个属性显示 Extra 值。

对于其中一些，有一个特定的属性。其他的显示为 message 属性的文本。

> The Extra column of EXPLAIN output contains additional information about how MySQL resolves the query. The following list explains the values that can appear in this column. Each item also indicates for JSON-formatted output which property displays the Extra value. For some of these, there is a specific property. The others display as the text of the message property.

如果希望查询尽可能快，请注意 `Using filesort` 和 `Using temporary` 的 Extra 列值，或者在 JSON-formatted EXPLAIN 输出中，`using_filesort` 和 `using_temporary_table` 属性为 true 的 Extra 列值。

> If you want to make your queries as fast as possible, look out for Extra column values of Using filesort and Using temporary, or, in JSON-formatted EXPLAIN output, for using_filesort and using_temporary_table properties equal to true.

- Child of 'table' pushed join@1 (JSON: message text)

	在可以下推到 NDB 内核的 join 中，这个表被引用为表的子表。仅在启用下推连接时才应用于 NDB 集群。

> This table is referenced as the child of table in a join that can be pushed down to the NDB kernel. Applies only in NDB Cluster, when pushed-down joins are enabled. See the description of the [ndb_join_pushdown](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-options-variables.html#sysvar_ndb_join_pushdown) server system variable for more information and examples.

- const row not found (JSON property: const_row_not_found)

	对于像 `SELECT ... FROM tbl_name` 查询，表是空的。

> For a query such as SELECT ... FROM tbl_name, the table was empty.

- Deleting all rows (JSON property: message)

	对于 DELETE，一些存储引擎(如 MyISAM)支持一个处理程序方法，该方法可以以简单而快速的方式删除所有表行。

	如果引擎使用此优化，则会显示此 Extra 值。

> For DELETE, some storage engines (such as [MyISAM](https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html)) support a handler method that removes all table rows in a simple and fast way. This Extra value is displayed if the engine uses this optimization.

- Distinct (JSON property: distinct)

	MySQL 正在寻找不同的值，因此在找到第一个匹配的行之后，它将停止对当前行组合的更多行搜索。

> MySQL is looking for distinct values, so it stops searching for more rows for the current row combination after it has found the first matching row.

- FirstMatch(tbl_name) (JSON property: first_match)

	tbl_name 使用了半连接 FirstMatch join 捷径策略。

> The semijoin FirstMatch join shortcutting strategy is used for tbl_name.

- Full scan on NULL key (JSON property: message)

	当优化器不能使用索引查找访问方法时，作为回退策略的子查询优化会发生这种情况。

> This occurs for subquery optimization as a fallback strategy when the optimizer cannot use an index-lookup access method.

- Impossible HAVING (JSON property: message)

	HAVING 子句总是返回 false，不能选择任何行。

> The HAVING clause is always false and cannot select any rows.

- Impossible WHERE (JSON property: message)

	WHERE 子句总是返回 false，不能选择任何行。

> The WHERE clause is always false and cannot select any rows.

- Impossible WHERE noticed after reading const tables (JSON property: message)

	MySQL 已经读取了所有 const(和系统)表，提醒 WHERE 子句总是返回 false。

> MySQL has read all const (and system) tables and notice that the WHERE clause is always false.

- LooseScan(m..n) (JSON property: message)

使用半连接 LooseScan 策略。m 和 n 是 key 部分的数字。
 
> The semijoin LooseScan strategy is used. m and n are key part numbers.

- No matching min/max row (JSON property: message)

没有行能满足这种查询条件，`SELECT MIN(...) FROM ... WHERE`

> No row satisfies the condition for a query such as SELECT MIN(...) FROM ... WHERE condition.

- no matching row in const table (JSON property: message)

对于使用 join 的查询，存在空表，或者没有满足唯一索引条件的行的表。

> For a query with a join, there was an empty table or a table with no rows satisfying a unique index condition.

- No matching rows after partition pruning (JSON property: message)

对于 DELETE 和 UPDATE，在分区剪枝后，优化器没有找到任何可以删除或更新的内容。类似 `Impossible WHERE for SELECT statements`
 
> For DELETE or UPDATE, the optimizer found nothing to delete or update after partition pruning. It is similar in meaning to Impossible WHERE for SELECT statements.

- No tables used (JSON property: message)

查询没有 FROM 子句，或者有 FROM DUAL 子句。

对于 INSERT 或 REPLACE 语句，当没有 SELECT 部分时，EXPLAIN 将显示此值。例如，它出现在 `EXPLAIN INSERT INTO t VALUES(10)` 中，因为这等同于 `EXPLAIN INSERT INTO t SELECT 10 FROM DUAL`。

> The query has no FROM clause, or has a FROM DUAL clause.

> For INSERT or REPLACE statements, EXPLAIN displays this value when there is no SELECT part. For example, it appears for EXPLAIN INSERT INTO t VALUES(10) because that is equivalent to EXPLAIN INSERT INTO t SELECT 10 FROM DUAL.

- Not exists (JSON property: message)

MySQL 能够对查询进行 LEFT JOIN 优化，并且在找到与 LEFT JOIN 条件匹配的行后，不会在该表中检查更多前一行组合的行。

> MySQL was able to do a LEFT JOIN optimization on the query and does not examine more rows in this table for the previous row combination after it finds one row that matches the LEFT JOIN criteria. Here is an example of the type of query that can be optimized this way:

下面是一个这种查询类型的例子，可以使用这种方式优化:

```sql
SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
  WHERE t2.id IS NULL;
```

**假设 `t2.id` 定义为 NOT NULL。在本例中，MySQL 扫描 t1 并使用 t1.id 的值查找 t2 中的行。如果 MySQL 在 t2 中找到匹配的行，它就知道 `t2.id` 永远不能为 NULL，并且不会扫描 t2 中具有相同 id 值的其余行。**

换句话说，对于 t1 中的每一行，MySQL 只需要在 t2 中执行一次查找，而不管 t2 中实际有多少行匹配。

> Assume that t2.id is defined as NOT NULL. In this case, MySQL scans t1 and looks up the rows in t2 using the values of t1.id. If MySQL finds a matching row in t2, it knows that t2.id can never be NULL, and does not scan through the rest of the rows in t2 that have the same id value. In other words, for each row in t1, MySQL needs to do only a single lookup in t2, regardless of how many rows actually match in t2.

在 MySQL 8.0.17 及以后版本中，这也表示了形成 WHERE 条件 的 NOT In(子查询) 或 NOT EXISTS(子查询)已经在内部转换为一个 antijoin。

这将删除子查询，并将其表放入最顶层查询的执行计划中，从而提供了改进的成本计划。

通过合并 semijoins 和 antijoins，优化器可以更自由地对执行计划中的表重新排序，在某些情况下会产生更快的执行计划。

> In MySQL 8.0.17 and later, this can also indicate that a WHERE condition of the form NOT IN (subquery) or NOT EXISTS (subquery) has been transformed internally into an antijoin. This removes the subquery and brings its tables into the plan for the topmost query, providing improved cost planning. By merging semijoins and antijoins, the optimizer can reorder tables in the execution plan more freely, in some cases resulting in a faster plan.

可以通过检查 EXPLAIN 执行后的 SHOW WARNINGS 中的 Message 列或 `EXPLAIN FORMAT=TREE` 的输出中，查看对给定查询执行 antijoin 转换的时间。

> You can see when an antijoin transformation is performed for a given query by checking the Message column from SHOW WARNINGS following execution of EXPLAIN, or in the output of EXPLAIN FORMAT=TREE.

注意：antijoin 是 table_a 和 table_b semijoin 下的补。antijoin 返回 table_a 中 table_b 没有匹配条件的所有行。

> Note:An antijoin is the complement of a semijoin table_a JOIN table_b ON condition. The antijoin returns all rows from table_a for which there is no row in table_b which matches condition.

- Plan isn't ready yet (JSON property: none)

当优化器尚未完成 为指定连接中的执行语句 创建执行计划时，这个值就会在`EXPLAIN FOR CONNECTION`中出现。

如果执行计划输出包含多个行，那么其中任何一行或所有行都可能具有这个 Extra 值，这取决于优化器在确定完整执行计划的进度。

> This value occurs with [EXPLAIN FOR CONNECTION](https://dev.mysql.com/doc/refman/8.0/en/explain-for-connection.html) when the optimizer has not finished creating the execution plan for the statement executing in the named connection. If execution plan output comprises multiple lines, any or all of them could have this Extra value, depending on the progress of the optimizer in determining the full execution plan.

- Range checked for each record (index map: N) (JSON property: message)

MySQL 没有找到好的索引来使用，但是发现一些索引可能会在前面表的列值已知之后使用。

对于前表中的每个行组合，MySQL 检查是否可以使用 `range` 或 `index_merge` 访问方法来检索行。这不是非常快，但比执行完全没有索引的 join 快。适用性标准如8.2.1.2节和8.2.1.3节所述，除了前表的所有列值都是已知的并被认为是常量。

> MySQL found no good index to use, but found that some of indexes might be used after column values from preceding tables are known. For each row combination in the preceding tables, MySQL checks whether it is possible to use a range or index_merge access method to retrieve rows. This is not very fast, but is faster than performing a join with no index at all. The applicability criteria are as described in [Section 8.2.1.2, “Range Optimization”](https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html), and [Section 8.2.1.3, “Index Merge Optimization”](https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html), with the exception that all column values for the preceding table are known and considered to be constants.

索引编号从 1 开始，顺序与表 `SHOW INDEX` 显示的顺序相同。

索引映射值N是位掩码值，表示哪些索引是候选索引。例如，0x19(二进制11001)的值意味着索引1、4和5被考虑。

> Indexes are numbered beginning with 1, in the same order as shown by [SHOW INDEX](https://dev.mysql.com/doc/refman/8.0/en/show-index.html) for the table. The index map value N is a bitmask value that indicates which indexes are candidates. For example, a value of 0x19 (binary 11001) means that indexes 1, 4, and 5 are considered.

- Recursive (JSON property: recursive)

这表示行被应用到递归 CTE 的 递归的 SELECT 部分。

> This indicates that the row applies to the recursive SELECT part of a recursive common table expression. See [Section 13.2.15, “WITH (Common Table Expressions)”](https://dev.mysql.com/doc/refman/8.0/en/with.html).

- Rematerialize (JSON property: rematerialize)

Rematerialize (X，…) 显示在表 T 的 EXPLAIN 行中，其中 X 是任何横向派生表，当读取 T 的新行时，该派生表的重新物化将被触发。

> Rematerialize (X,...) is displayed in the EXPLAIN row for table T, where X is any lateral derived table whose rematerialization is triggered when a new row of T is read. For example:

例如:

```sql
SELECT
  ...
FROM
  t,
  LATERAL (derived table that refers to t) AS dt
...
```

派生表的内容将被重新物化，以便在每次由顶层查询处理 t 的新行时，使其更新。

> The content of the derived table is rematerialized to bring it up to date each time a new row of t is processed by the top query.

- Scanned N databases (JSON property: message)

这表示在处理对 INFORMATION_SCHEMA 表的查询时，服务器扫描了多少目录。N的值可以是0,1，或者全部。

> This indicates how many directory scans the server performs when processing a query for INFORMATION_SCHEMA tables, as described in [Section 8.2.3, “Optimizing INFORMATION_SCHEMA Queries”](https://dev.mysql.com/doc/refman/8.0/en/information-schema-optimization.html). The value of N can be 0, 1, or all.

- Select tables optimized away (JSON property: message)

优化器决定:1)最多返回一行。2)为了生成这一行，必须读取一组确定性的行。当在优化阶段可以读取要读取的行(例如，通过读取索引行)时，就不需要在查询执行期间读取任何表。

> The optimizer determined 1) that at most one row should be returned, and 2) that to produce this row, a deterministic set of rows must be read. When the rows to be read can be read during the optimization phase (for example, by reading index rows), there is no need to read any tables during query execution.

当查询被隐式分组时(包含一个聚合函数，但不包含 GROUP BY 子句)，则满足第一个条件。

如果使用每个索引执行一行查找，则满足第二个条件。

读取的索引数决定要读取的行数。

> The first condition is fulfilled when the query is implicitly grouped (contains an aggregate function but no GROUP BY clause). The second condition is fulfilled when one row lookup is performed per index used. The number of indexes read determines the number of rows to read.

> Consider the following implicitly grouped query:

考虑以下隐式分组查询:

```sql
SELECT MIN(c1), MIN(c2) FROM t1;
```

假设 MIN(c1) 可以通过读取一个索引行来检索，而 MIN(c2) 可以通过从另一个索引中读取一行来检索。

也就是说，对于每一列 c1 和 c2，都存在一个索引，其中该列是索引的第一列。

在本例中，通过读取两个确定的行返回一行。

> Suppose that MIN(c1) can be retrieved by reading one index row and MIN(c2) can be retrieved by reading one row from a different index. That is, for each column c1 and c2, there exists an index where the column is the first column of the index. In this case, one row is returned, produced by reading two deterministic rows.

> This Extra value does not occur if the rows to read are not deterministic. Consider this query:

如果要读取的行不是确定的，则不会出现此 Extra 值。考虑一下这个查询:

```sql
SELECT MIN(c2) FROM t1 WHERE c1 <= 10;
```

> Suppose that (c1, c2) is a covering index. Using this index, all rows with c1 <= 10 must be scanned to find the minimum c2 value. By contrast, consider this query:

假设 (c1, c2) 是覆盖索引。使用这个索引，必须扫描`c1 <= 10`的所有行，以找到最小的 c2 值。相比之下，考虑以下查询:

```sql
SELECT MIN(c2) FROM t1 WHERE c1 = 10;
```

在本例中，`c1 = 10`的第一个索引行包含最小的 c2 值。只有一行必须读取,以产生返回的行。

> In this case, the first index row with c1 = 10 contains the minimum c2 value. Only one row must be read to produce the returned row.

对于为每个表维护精确行数的存储引擎(比如 MyISAM，而不是 InnoDB)，对于缺失 WHERE 子句或始终为 true 且没有 GROUP BY 子句的 `count(*)` 查询时，就会出现这个 Extra 值。(这是一个隐式分组查询的实例，存储引擎会影响是否可以读取确定的行数。)

> For storage engines that maintain an exact row count per table (such as MyISAM, but not InnoDB), this Extra value can occur for `COUNT(*)` queries for which the WHERE clause is missing or always true and there is no GROUP BY clause. (This is an instance of an implicitly grouped query where the storage engine influences whether a deterministic number of rows can be read.)

- Skip_open_table, Open_frm_only, Open_full_table (JSON property: message)

These values indicate file-opening optimizations that apply to queries for INFORMATION_SCHEMA tables.

(1)Skip_open_table:不需要打开表文件。这些信息已经可以从数据字典中获得。

(2)Open_frm_only:只需要读取数据字典来获取表信息。

(3)Open_full_table:未优化的信息查找。表信息必须从数据字典和通过读取表文件来获取。

> Skip_open_table: Table files do not need to be opened. The information is already available from the data dictionary.

> Open_frm_only: Only the data dictionary need be read for table information.

> Open_full_table: Unoptimized information lookup. Table information must be read from the data dictionary and by reading table files.

- Start temporary, End temporary (JSON property: message)

这表示将临时表用于半连接重复淘汰策略。

> This indicates temporary table use for the semijoin Duplicate Weedout strategy.

- unique row not found (JSON property: message)

像 `SELECT ... FROM tbl_name` 的查询，对于表中的 UNIQUE index 和 PRIMARY KEY ，没有行能满足条件。

> For a query such as SELECT ... FROM tbl_name, no rows satisfy the condition for a UNIQUE index or PRIMARY KEY on the table.

- Using filesort (JSON property: using_filesort)

> MySQL must do an extra pass to find out how to retrieve the rows in sorted order. The sort is done by going through all rows according to the join type and storing the sort key and pointer to the row for all rows that match the WHERE clause. The keys then are sorted and the rows are retrieved in sorted order. See [Section 8.2.1.16, “ORDER BY Optimization”](https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html).

- Using index (JSON property: using_index)

> The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index.

> For InnoDB tables that have a user-defined clustered index, that index can be used even when Using index is absent from the Extra column. This is the case if type is index and key is PRIMARY.

- Using index condition (JSON property: using_index_condition)

> Tables are read by accessing index tuples and testing them first to determine whether to read full table rows. In this way, index information is used to defer (“push down”) reading full table rows unless it is necessary. See [Section 8.2.1.6, “Index Condition Pushdown Optimization”](https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html).

- Using index for group-by (JSON property: using_index_for_group_by)

> Similar to the Using index table access method, Using index for group-by indicates that MySQL found an index that can be used to retrieve all columns of a GROUP BY or DISTINCT query without any extra disk access to the actual table. Additionally, the index is used in the most efficient way so that for each group, only a few index entries are read. For details, see [Section 8.2.1.17, “GROUP BY Optimization”](https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html).

- Using index for skip scan (JSON property: using_index_for_skip_scan)

> Indicates that the Skip Scan access method is used. See [Skip Scan Range Access Method](https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html#range-access-skip-scan).

- Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access), Using join buffer (hash join) (JSON property: using_join_buffer)

> Tables from earlier joins are read in portions into the join buffer, and then their rows are used from the buffer to perform the join with the current table. (Block Nested Loop) indicates use of the Block Nested-Loop algorithm, (Batched Key Access) indicates use of the Batched Key Access algorithm, and (hash join) indicates use of a hash join. That is, the keys from the table on the preceding line of the EXPLAIN output are buffered, and the matching rows are fetched in batches from the table represented by the line in which Using join buffer appears.

> In JSON-formatted output, the value of using_join_buffer is always one of Block Nested Loop, Batched Key Access, or hash join.

> Hash joins are available beginning with MySQL 8.0.18; the Block Nested-Loop algorithm is not used in MySQL 8.0.20 or later MySQL releases. For more information about these optimizations, see [Section 8.2.1.4, “Hash Join Optimization”](https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html), and [Block Nested-Loop Join Algorithm](https://dev.mysql.com/doc/refman/8.0/en/nested-loop-joins.html#block-nested-loop-join-algorithm).

> See Batched Key Access Joins, for information about the Batched Key Access algorithm.

- Using MRR (JSON property: message)

> Tables are read using the Multi-Range Read optimization strategy. See [Section 8.2.1.11, “Multi-Range Read Optimization”](https://dev.mysql.com/doc/refman/8.0/en/mrr-optimization.html).

- Using sort_union(...), Using union(...), Using intersect(...) (JSON property: message)

> These indicate the particular algorithm showing how index scans are merged for the index_merge join type. See [Section 8.2.1.3, “Index Merge Optimization”](https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html).

- Using temporary (JSON property: using_temporary_table)

> To resolve the query, MySQL needs to create a temporary table to hold the result. This typically happens if the query contains GROUP BY and ORDER BY clauses that list columns differently.

- Using where (JSON property: attached_condition)

> A WHERE clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the Extra value is not Using where and the table join type is ALL or index.

> Using where has no direct counterpart in JSON-formatted output; the attached_condition property contains any WHERE condition used.

- Using where with pushed condition (JSON property: message)

> This item applies to NDB tables only. It means that NDB Cluster is using the Condition Pushdown optimization to improve the efficiency of a direct comparison between a nonindexed column and a constant. In such cases, the condition is “pushed down” to the cluster's data nodes and is evaluated on all data nodes simultaneously. This eliminates the need to send nonmatching rows over the network, and can speed up such queries by a factor of 5 to 10 times over cases where Condition Pushdown could be but is not used. For more information, see [Section 8.2.1.5, “Engine Condition Pushdown Optimization”](https://dev.mysql.com/doc/refman/8.0/en/engine-condition-pushdown-optimization.html).

- Zero limit (JSON property: message)

> The query had a LIMIT 0 clause and cannot select any rows.

## 4、EXPLAIN Output Interpretation

> You can get a good indication of how good a join is by taking the product of the values in the rows column of the EXPLAIN output. This should tell you roughly how many rows MySQL must examine to execute the query. If you restrict queries with the [max_join_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_join_size) system variable, this row product also is used to determine which multiple-table SELECT statements to execute and which to abort. See [Section 5.1.1, “Configuring the Server”](https://dev.mysql.com/doc/refman/8.0/en/server-configuration.html).

> The following example shows how a multiple-table join can be optimized progressively based on the information provided by EXPLAIN.

> Suppose that you have the SELECT statement shown here and that you plan to examine it using EXPLAIN:

```sql
EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
               tt.ProjectReference, tt.EstimatedShipDate,
               tt.ActualShipDate, tt.ClientID,
               tt.ServiceCodes, tt.RepetitiveID,
               tt.CurrentProcess, tt.CurrentDPPerson,
               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
               et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
          AND tt.ActualPC = et.EMPLOYID
          AND tt.AssignedPC = et_1.EMPLOYID
          AND tt.ClientID = do.CUSTNMBR;
```

> For this example, make the following assumptions:

> The columns being compared have been declared as follows.

Table | Column | Data Type
---|:---|:---
tt | ActualPC | CHAR(10)
tt | AssignedPC | CHAR(10)
tt | ClientID | CHAR(10)
et | EMPLOYID | CHAR(15)
do | CUSTNMBR | CHAR(15)

> The tables have the following indexes.

Table | Index
---|:---
tt | ActualPC
tt | AssignedPC
tt | ClientID
et | EMPLOYID (primary key)
do | CUSTNMBR (primary key)

> The tt.ActualPC values are not evenly distributed.

> Initially, before any optimizations have been performed, the EXPLAIN statement produces the following information:

```sql
table type possible_keys key  key_len ref  rows  Extra
et    ALL  PRIMARY       NULL NULL    NULL 74
do    ALL  PRIMARY       NULL NULL    NULL 2135
et_1  ALL  PRIMARY       NULL NULL    NULL 74
tt    ALL  AssignedPC,   NULL NULL    NULL 3872
           ClientID,
           ActualPC
      Range checked for each record (index map: 0x23)
```

> Because type is ALL for each table, this output indicates that MySQL is generating a Cartesian product of all the tables; that is, every combination of rows. This takes quite a long time, because the product of the number of rows in each table must be examined. For the case at hand, this product is 74 × 2135 × 74 × 3872 = 45,268,558,720 rows. If the tables were bigger, you can only imagine how long it would take.

> One problem here is that MySQL can use indexes on columns more efficiently if they are declared as the same type and size. In this context, VARCHAR and CHAR are considered the same if they are declared as the same size. tt.ActualPC is declared as CHAR(10) and et.EMPLOYID is CHAR(15), so there is a length mismatch.

> To fix this disparity between column lengths, use [ALTER TABLE](https://dev.mysql.com/doc/refman/8.0/en/alter-table.html) to lengthen ActualPC from 10 characters to 15 characters:

```sql
mysql> ALTER TABLE tt MODIFY ActualPC VARCHAR(15);
```

> Now tt.ActualPC and et.EMPLOYID are both VARCHAR(15). Executing the EXPLAIN statement again produces this result:

```sql
table type   possible_keys key     key_len ref         rows    Extra
tt    ALL    AssignedPC,   NULL    NULL    NULL        3872    Using
             ClientID,                                         where
             ActualPC
do    ALL    PRIMARY       NULL    NULL    NULL        2135
      Range checked for each record (index map: 0x1)
et_1  ALL    PRIMARY       NULL    NULL    NULL        74
      Range checked for each record (index map: 0x1)
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1
```

> This is not perfect, but is much better: The product of the rows values is less by a factor of 74. This version executes in a couple of seconds.

> A second alteration can be made to eliminate the column length mismatches for the tt.AssignedPC = et_1.EMPLOYID and tt.ClientID = do.CUSTNMBR comparisons:

```sql
mysql> ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
                      MODIFY ClientID   VARCHAR(15);
```

> After that modification, EXPLAIN produces the output shown here:

```sql
table type   possible_keys key      key_len ref           rows Extra
et    ALL    PRIMARY       NULL     NULL    NULL          74
tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using
             ClientID,                                         where
             ActualPC
et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1
```

> At this point, the query is optimized almost as well as possible. The remaining problem is that, by default, MySQL assumes that values in the tt.ActualPC column are evenly distributed, and that is not the case for the tt table. Fortunately, it is easy to tell MySQL to analyze the key distribution:

```sql
mysql> ANALYZE TABLE tt;
```

> With the additional index information, the join is perfect and EXPLAIN produces this result:

```sql
table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using
             ClientID,                                        where
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1
```

> The rows column in the output from EXPLAIN is an educated guess from the MySQL join optimizer. Check whether the numbers are even close to the truth by comparing the rows product with the actual number of rows that the query returns. If the numbers are quite different, you might get better performance by using STRAIGHT_JOIN in your SELECT statement and trying to list the tables in a different order in the FROM clause. (However, STRAIGHT_JOIN may prevent indexes from being used because it disables semijoin transformations. See [Section 8.2.2.1, “Optimizing IN and EXISTS Subquery Predicates with Semijoin Transformations”.](https://dev.mysql.com/doc/refman/8.0/en/semijoins.html))

> It is possible in some cases to execute statements that modify data when [EXPLAIN SELECT](https://dev.mysql.com/doc/refman/8.0/en/explain.html) is used with a subquery; for more information, see [Section 13.2.11.8, “Derived Tables”](https://dev.mysql.com/doc/refman/8.0/en/derived-tables.html).